package main;

import environment.*;
import java.util.Iterator;
import type.*;
import beaver.*;
import node.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLtUSL4KI$bum2oweoA8hYWZiWaJ5aw1aNGa2aiM55GcIEG4FL1G38YYuQm95HPH5G4G" +
		"51KKa6522A9WJ1WmOxiw4yQxykgTcvitCcu55yESVplo#LzLL$Ughr$rUTJVWpqGdL40xd8" +
		"u2bCV3E0W7un0SYZ8eYyEGXN8u74VWI9o1#cY8DZWPP#8ivEDivA04ax2$V8dxP1iQepAEn" +
		"z4u2YVWH8p5hRW0Gz41dT4LFN0U1eL4EE0FS1kslkPAxetAFJR2BM$k1dSXsg8HJYFt34Qe" +
		"gFgpM0wFSVPBYH3CzC1IPTeIpN4RN970A3NJJAViHPvZz1bQo3OoHNZQwsoCpSZJlrGynof" +
		"F7x8CK9w5oZCg8y$0Kl4SfpmNa#UVoZDQUUPav1bIAfvNiPdNyPX3djdA4tsVDcNa6LCAdY" +
		"hwDEDm6NcgQkjVM8Jho3Cx8yz3QNboK4qZTKGNJDQyAzbHoa4sgYCNDN4Iwg1UWgyn$q5V3" +
		"lw16Xgf04kJujoGDiupw9uKPmLMeYdoD5PYd5vfu#JW$0o#QHbyqzFwXjCRz5sOuBq5YvCo" +
		"7unQclK8p4XYkJqjoqjyUuA#r9cVXGcu7bDmAIx75RWI4t4LQYlJJ7aovhyfu8$QYaDiTuJ" +
		"OreROreVONWdOKZFzs$9Njap2IBlMFa5jeT5m9#wYNcJrEJ7jRhJ2lIX2NNt7YZZxyp4F3s" +
		"0gRiRLk0RN1hHxGgsJv0qRwqP6dMsr#p4tnh01InWr1uzXcNm6dzPFiLg$YaVC6YgVX4RDY" +
		"UloagxXHwD1GgquHLkdgcoYihNAJZX7vRbMTbDxJvMzLVPJUP7AOIeVPUxZMBUOErRB9exR" +
		"0Zo8nx4EA#KLF84dyHIVPHNMu3ayZqlmD5x0YzZA$ylC6TWYFpDE8zRF9gnpftEUcd5zRy5" +
		"LlXLpR1ERhRPmu78luNCliJztEcOjTvcTm$fkh5cijv6QNilMz8giFvNu$CVO5ROoLx$ZGo" +
		"BK$0FSXgs7lMQnsaUuAoftLgcu7VQFwYUnbZKDZR3dcGvZxMx0Uet0A7cQwOYzo1EzCviyM" +
		"SfJJdagxWCUmtAAyjHLdfxxWETKyWnKdkhAu#n5dbxSeRYCRDw3FEM9la#3zXfFzBvkd9Fu" +
		"#sRs2NN8axU7FF5HAiU$ax2lScafhpkh2Zp917qr#0$wNBurGSR4E3NInkcUnE7o55F8$KC" +
		"qrkxcazcNcy5NBwqlYzwWx#G4Rts#gucPDunbFI1b97kdPJ5lJz2NElFjU6xfm3hVaLM#C#" +
		"jy5#wAeqpLEUvX$Z$3bfhftvQ$jgMcjMHJgskrShmwV0#DxiIqRgmcHe##OsLYir#5U$ogt" +
		"ELN2sZPeLPJ2qsiYwZbMQsEvOWm5A0FDPUdl7xyDljJpurzCKFj6feR6jLDu7NrZiHQ4Mtj" +
		"AsboxyQwPN9tx5YURskogLkcWdhMrjsk1nxFtddst6b6jnQoHTYd5bVorww4$UKIxOcUn7X" +
		"Y556UM6hyUm8H#PMY0U2y6xK1BctEvO3dKzBabQ6n4sK5oYwKbG6$4cKDIjxhrQFTj1jHzg" +
		"1iIRc8iXtbXvHT6UV8I6olWFUmdpUGjdpAaPHVnBbvNeKtZZaWO5l6TWdbPesnYhYAjY5Xp" +
		"qJxH5xUqxvJ6N#BsgUpVGlRMzLt5srbLMTyjwhgYwdNZ#ZEeRpC9JggRpbzpQYyHUoWlupQ" +
		"rz3UWUtcsbxFTcygtr9VeB6oLTOXngZEkNIkLftzlQsKytOrR$5dTOg8xKasviMr7Ixdnwt" +
		"Dc6zgJk$hE73StUkfN14Oizlf$vZOg7tV8JuYFjNsZdXVRpldC2lGtadyJ9iJQViJcCCCOd" +
		"vYNjwl4OctjTyebQE9QubhY2h42BNt9oQhpXsjVr0ybizvzQSGbn6N48E9iW4$nyKlLdqGS" +
		"GGnITj3u$rOfy2T3RmLfitlOHr5hrsD#wx0NtvIUw7ARH7f7AvolCg9AajKRb3vJKIwxLHg" +
		"Fsz9u5aFKAdliby#DH#$GaYEBPFwLDgzP$EFJMfN2UZL0dfUGA#TnBqVCKrz#grXhSgTQcy" +
		"OaKwUjXj5f7i2BvkqxvVnc4w1zgFVAOpRtGjtvxbs$TpUt43CqIedH6ryTqmDQ9XuZpivAK" +
		"Rndd7xDVKPYvFiqPgo8VszphgaUne4yal9nunVm3yh4ASQswq3lfBKU$4QH#B$iWsndxmWp" +
		"yjpygmy8sjbZQoMLVAqF28Fos9vI8fiZvKoXzTxYTd4FSJTn2pYJc8cmMeYh51o6t6hi8OB" +
		"QxVSOU##MOerpdroaznljHNskbocopIvKMwGgRAClPwYhKWUjxuYUSpAfVQwn5uVrOnVLFa" +
		"WiKZrXR7dMI0bCjzgN1VaVNbFxU$8J$AZx9GVv7lvJhwLR#I$yX$QTyY$vUl0U7nER5VzO$" +
		"b8jGzKVaMyBMzP$GlvKAtlgfmd3vWA9QyJhn9RPKiixilskj5Uryi617woMSoy$4z#q$OlX" +
		"5dvns04TtoihOJBywU1mrE6ptE6m$rxE3e5q9xehEZ0#yoQVmxtCWRdChRPqqNHXV6xiizW" +
		"oi5izwRUbFsRiZt4mkoFp9xI8npkzK0utEMvXCFTb6lHX$e5H3zMaNxSh$Pblxvi5$A#Ghk" +
		"VydYgzBaNSGc79ze8ccL02$PloVwDAOSptd3QXZ7ECCfMbAs9DiIPn5b4Szg3oEUpvlFUiu" +
		"csp6i0#vYJNK#skTSXFEu97S8dp4dQIuARHW$huyJG90GZVmSACzSk");

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};
 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
		System.err.format("*** " + msg + " ligne %d, colonne %d\n",
			Symbol.getLine(token.getStart()),
			Symbol.getColumn(token.getStart()));
	}
	
	/*
	 * Environnements disponibles pour la gestion des types complexes, des variables et des fonctions.
	 */
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local_variables_stack");
	private String type_declaration_name;
	
	public void backtrace() 
	{
		typeEnvironment.backtrace();
		procedureEnvironment.backtrace();
		stackEnvironment.backtrace();
	}

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN6,	// [0] program = type_declaration_part variable_declaration_part procedure_definition_part TOKEN_BEGIN statement_list TOKEN_END; returns 'TOKEN_END' although none is marked
			Action.NONE,  	// [1] type_declaration_part = 
			RETURN2,	// [2] type_declaration_part = TOKEN_TYPE type_declaration_list; returns 'type_declaration_list' although none is marked
			new Action() {	// [3] type_declaration_list = type_declaration_list type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] type_declaration_list = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [5] type_declaration = type_declaration_head.tname TOKEN_AFF type.ty TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_tname = _symbols[offset + 1];
					final String tname = (String) _symbol_tname.value;
					final Symbol _symbol_ty = _symbols[offset + 3];
					final Type ty = (Type) _symbol_ty.value;
					 	NodeId node = new NodeId(tname, ty); stackEnvironment.putVariable(tname, node); 
																	return node;
				}
			},
			Action.RETURN,	// [6] type_declaration_head = TOKEN_IDENTIFIER
			Action.RETURN,	// [7] type = simple_type
			Action.RETURN,	// [8] type = named_type
			Action.RETURN,	// [9] type = index_type
			Action.RETURN,	// [10] type = array_type
			Action.RETURN,	// [11] type = pointer_type
			Action.RETURN,	// [12] type = structure_type
			new Action() {	// [13] simple_type = TOKEN_STRING
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [14] simple_type = TOKEN_INTEGER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [15] simple_type = TOKEN_BOOLEAN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			new Action() {	// [16] named_type = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return typeEnvironment.getVariable(name);
				}
			},
			Action.RETURN,	// [17] index_type = enumerated_type
			Action.RETURN,	// [18] index_type = subrange_type
			RETURN4,	// [19] enumerated_type = init_enumerated_type TOKEN_LPAR identifier_list TOKEN_RPAR; returns 'TOKEN_RPAR' although none is marked
			Action.NONE,  	// [20] init_enumerated_type = 
			new Action() {	// [21] subrange_type = TOKEN_LIT_INTEGER.int1 TOKEN_DOTDOT TOKEN_LIT_INTEGER.int2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_int1 = _symbols[offset + 1];
					final Integer int1 = (Integer) _symbol_int1.value;
					final Symbol _symbol_int2 = _symbols[offset + 3];
					final Integer int2 = (Integer) _symbol_int2.value;
					 return new TypeArrayRange(new TypeInt(int1), new TypeInt(int2));
				}
			},
			RETURN3,	// [22] subrange_type = TOKEN_IDENTIFIER.name1 TOKEN_DOTDOT TOKEN_IDENTIFIER.name2; returns 'name2' although more are marked
			new Action() {	// [23] array_type = TOKEN_ARRAY TOKEN_LBRACKET range_type.r TOKEN_RBRACKET TOKEN_OF type.ty
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 3];
					final TypeRange r = (TypeRange) _symbol_r.value;
					final Symbol _symbol_ty = _symbols[offset + 6];
					final Type ty = (Type) _symbol_ty.value;
					 return new TypeArray(r, ty);
				}
			},
			Action.RETURN,	// [24] range_type = enumerated_type
			Action.RETURN,	// [25] range_type = subrange_type
			Action.RETURN,	// [26] range_type = named_type
			new Action() {	// [27] pointer_type = TOKEN_CIRC type.ty
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ty = _symbols[offset + 2];
					final Type ty = (Type) _symbol_ty.value;
					 return new TypePointer(ty);
				}
			},
			RETURN4,	// [28] structure_type = TOKEN_STRUCT TOKEN_LBRACE feature_list_type TOKEN_RBRACE; returns 'TOKEN_RBRACE' although none is marked
			new Action() {	// [29] feature_list_type = feature_list_type feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [30] feature_list_type = feature_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN4,	// [31] feature_type = TOKEN_IDENTIFIER TOKEN_COLON type TOKEN_SEMIC; returns 'TOKEN_SEMIC' although none is marked
			Action.NONE,  	// [32] variable_declaration_part = 
			new Action() {	// [33] variable_declaration_part = TOKEN_VAR variable_declaration_list.list
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 2];
					final Node list = (Node) _symbol_list.value;
					 return list;
				}
			},
			new Action() {	// [34] variable_declaration_list = variable_declaration_list.list variable_declaration.dec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_dec = _symbols[offset + 2];
					final Node dec = (Node) _symbol_dec.value;
					 list.add(dec); return list;
				}
			},
			Action.RETURN,	// [35] variable_declaration_list = variable_declaration
			new Action() {	// [36] variable_declaration = identifier_list.list TOKEN_COLON type.ty TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_ty = _symbols[offset + 3];
					final Type ty = (Type) _symbol_ty.value;
					 	
		NodeList node_list = new NodeList(); 
		Iterator<String> itr = list.iterator();
		while(itr.hasNext()) 
		{
	         String name = itr.next();
	         NodeId node = new NodeId(name, ty);
	         stackEnvironment.putVariable(name, node);
	         node_list.add(node);
      	} 
      	return node_list;
				}
			},
			new Action() {	// [37] identifier_list = identifier_list.list TOKEN_COMMA TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_name = _symbols[offset + 3];
					final String name = (String) _symbol_name.value;
					 list.add(name); return list;
				}
			},
			new Action() {	// [38] identifier_list = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return new IdentifierList(name);
				}
			},
			Action.NONE,  	// [39] procedure_definition_part = 
			Action.RETURN,	// [40] procedure_definition_part = procedure_definition_list
			new Action() {	// [41] procedure_definition_list = procedure_definition_list procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [42] procedure_definition_list = procedure_definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			RETURN2,	// [43] procedure_definition = procedure_definition_head block; returns 'block' although none is marked
			RETURN2,	// [44] procedure_definition = procedure_declaration_head TOKEN_SEMIC; returns 'TOKEN_SEMIC' although none is marked
			Action.RETURN,	// [45] procedure_definition_head = procedure_head
			Action.RETURN,	// [46] procedure_declaration_head = procedure_head
			RETURN5,	// [47] procedure_head = TOKEN_PROCEDURE TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR; returns 'TOKEN_RPAR' although none is marked
			RETURN7,	// [48] procedure_head = TOKEN_FUNCTION TOKEN_IDENTIFIER TOKEN_LPAR argt_part TOKEN_RPAR TOKEN_COLON type; returns 'type' although none is marked
			Action.NONE,  	// [49] argt_part = 
			Action.RETURN,	// [50] argt_part = argt_list
			new Action() {	// [51] argt_list = argt_list.list TOKEN_COMMA argt.node
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_node = _symbols[offset + 3];
					final Node node = (Node) _symbol_node.value;
					 list.add(node); return list;
				}
			},
			new Action() {	// [52] argt_list = argt.node
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 1];
					final Node node = (Node) _symbol_node.value;
					 return new NodeList(node);
				}
			},
			new Action() {	// [53] argt = TOKEN_IDENTIFIER.name TOKEN_COLON type.ty
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_ty = _symbols[offset + 3];
					final Type ty = (Type) _symbol_ty.value;
					 	NodeId node = new NodeId(name, ty); stackEnvironment.putVariable(name, node); 
													return node;
				}
			},
			RETURN4,	// [54] block = variable_declaration_part TOKEN_BEGIN statement_list TOKEN_END; returns 'TOKEN_END' although none is marked
			new Action() {	// [55] statement_list = statement_list statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [56] statement_list = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [57] statement = simple_statement
			Action.RETURN,	// [58] statement = structured_statement
			Action.RETURN,	// [59] simple_statement = assignment_statement
			Action.RETURN,	// [60] simple_statement = procedure_statement
			Action.RETURN,	// [61] simple_statement = new_statement
			Action.RETURN,	// [62] simple_statement = dispose_statement
			Action.RETURN,	// [63] simple_statement = println_statement
			Action.RETURN,	// [64] simple_statement = readln_statement
			new Action() {	// [65] simple_statement = return_statement.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 1];
					final NodeReturn r = (NodeReturn) _symbol_r.value;
					 return new NodeReturn(r);
				}
			},
			new Action() {	// [66] assignment_statement = variable_access.v TOKEN_AFF expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final NodeExp v = (NodeExp) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeAssign(v, e);
				}
			},
			RETURN2,	// [67] procedure_statement = procedure_expression TOKEN_SEMIC; returns 'TOKEN_SEMIC' although none is marked
			new Action() {	// [68] procedure_expression = TOKEN_IDENTIFIER.name TOKEN_LPAR expression_part.ep TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol _symbol_ep = _symbols[offset + 3];
					final NodeList ep = (NodeList) _symbol_ep.value;
					 	NodeId funct = procedureEnvironment.getVariable(name); 
																			return new NodeCallFct( name, (TypeFunct)funct.getType(), ep);
				}
			},
			Action.NONE,  	// [69] expression_part = 
			Action.RETURN,	// [70] expression_part = expression_list
			new Action() {	// [71] expression_list = expression_list.list TOKEN_COMMA expression.node
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_node = _symbols[offset + 3];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 list.add(node); return list;
				}
			},
			new Action() {	// [72] expression_list = expression.node
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_node = _symbols[offset + 1];
					final NodeExp node = (NodeExp) _symbol_node.value;
					 return new NodeList(node);
				}
			},
			new Action() {	// [73] new_statement = TOKEN_NEW variable_access.v TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 2];
					final NodeExp v = (NodeExp) _symbol_v.value;
					 return new NodeNew(v);
				}
			},
			new Action() {	// [74] dispose_statement = TOKEN_DISPOSE variable_access.v TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 2];
					final NodeExp v = (NodeExp) _symbol_v.value;
					 return new NodeDispose(v);
				}
			},
			RETURN2,	// [75] println_statement = TOKEN_PRINTLN expression.e TOKEN_SEMIC
			new Action() {	// [76] readln_statement = TOKEN_READLN expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
		String name = new String("readln");
		NodeId(name, typeFct(name));
	    procedureEnvironment.putVariable(name, node);
      	return node_list;
				}
			},
			new Action() {	// [77] return_statement = TOKEN_RETURN expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeReturn(e);
				}
			},
			Action.RETURN,	// [78] structured_statement = block
			Action.RETURN,	// [79] structured_statement = if_statement
			Action.RETURN,	// [80] structured_statement = while_statement
			Action.RETURN,	// [81] structured_statement = switch_statement
			new Action() {	// [82] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.stm1 TOKEN_ELSE statement.stm2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm1 = _symbols[offset + 4];
					final Node stm1 = (Node) _symbol_stm1.value;
					final Symbol _symbol_stm2 = _symbols[offset + 6];
					final Node stm2 = (Node) _symbol_stm2.value;
					 return new NodeIf(e, stm1, stm2);
				}
			},
			new Action() {	// [83] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeIf(e, stm);
				}
			},
			new Action() {	// [84] while_statement = TOKEN_WHILE expression.e TOKEN_DO statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeWhile(e, stm);
				}
			},
			new Action() {	// [85] switch_statement = TOKEN_SWITCH expression.e TOKEN_BEGIN case_statement_list.stm TOKEN_END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final NodeList stm = (NodeList) _symbol_stm.value;
					 return new NodeSwitch(e, stm);
				}
			},
			new Action() {	// [86] case_statement_list = case_statement_list.list case_statement.cstmn case_default.cdef
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final NodeList list = (NodeList) _symbol_list.value;
					final Symbol _symbol_cstmn = _symbols[offset + 2];
					final NodeList cstmn = (NodeList) _symbol_cstmn.value;
					final Symbol _symbol_cdef = _symbols[offset + 3];
					final NodeCase cdef = (NodeCase) _symbol_cdef.value;
					 list.add(cstmn); list.add(cdef); return list;
				}
			},
			Action.RETURN,	// [87] case_statement_list = case_statement
			new Action() {	// [88] case_statement = TOKEN_CASE identifier_list.list TOKEN_COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 2];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					 	
		NodeList node_list = new NodeList(); 
		Iterator<String> itr = list.iterator();
		while(itr.hasNext()) 
		{
	         String name = itr.next();
	         NodeCase newcase = new NodeCase(name, stm);
	         node_list.add(newcase);
      	} 
      	return node_list;
				}
			},
			Action.NONE,  	// [89] case_default = 
			new Action() {	// [90] case_default = TOKEN_DEFAULT TOKEN_COLON statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 3];
					final Node stm = (Node) _symbol_stm.value;
					 return new NodeCase(stm);
				}
			},
			new Action() {	// [91] variable_access = TOKEN_IDENTIFIER.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					 return stackEnvironment.getVariable(name);
				}
			},
			new Action() {	// [92] variable_access = variable_access.t TOKEN_LBRACKET expression.i TOKEN_RBRACKET
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final NodeExp t = (NodeExp) _symbol_t.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final NodeExp i = (NodeExp) _symbol_i.value;
					 return new NodeArrayAccess(t, i);
				}
			},
			new Action() {	// [93] variable_access = expression.e TOKEN_CIRC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodePtrAccess(e);
				}
			},
			new Action() {	// [94] expression = expression.e1 TOKEN_PLUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("+", e1, e2);
				}
			},
			new Action() {	// [95] expression = expression.e1 TOKEN_MINUS expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("-", e1, e2);
				}
			},
			new Action() {	// [96] expression = expression.e1 TOKEN_TIMES expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("*", e1, e2);
				}
			},
			new Action() {	// [97] expression = expression.e1 TOKEN_DIV expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("/", e1, e2);
				}
			},
			new Action() {	// [98] expression = TOKEN_MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("-", e);
				}
			},
			new Action() {	// [99] expression = expression.e1 TOKEN_OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("||", e1, e2);
				}
			},
			new Action() {	// [100] expression = expression.e1 TOKEN_AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("&&", e1, e2);
				}
			},
			new Action() {	// [101] expression = TOKEN_NOT expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("!", e);
				}
			},
			new Action() {	// [102] expression = expression.e1 TOKEN_LT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("<", e1, e2);
				}
			},
			new Action() {	// [103] expression = expression.e1 TOKEN_LE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("<=", e1, e2);
				}
			},
			new Action() {	// [104] expression = expression.e1 TOKEN_GT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(">", e1, e2);
				}
			},
			new Action() {	// [105] expression = expression.e1 TOKEN_GE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(">=", e1, e2);
				}
			},
			new Action() {	// [106] expression = expression.e1 TOKEN_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("==", e1, e2);
				}
			},
			new Action() {	// [107] expression = expression.e TOKEN_NE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("!=", e);
				}
			},
			new Action() {	// [108] expression = TOKEN_LPAR expression.e TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return e;
				}
			},
			Action.RETURN,	// [109] expression = procedure_expression
			new Action() {	// [110] expression = variable_access.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final NodeExp v = (NodeExp) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [111] expression = literal.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final NodeLiteral l = (NodeLiteral) _symbol_l.value;
					 return l;
				}
			},
			new Action() {	// [112] literal = TOKEN_LIT_INTEGER.val
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_val = _symbols[offset + 1];
					final Integer val = (Integer) _symbol_val.value;
					 return new NodeLiteral(new TypeInt(), val);
				}
			},
			new Action() {	// [113] literal = TOKEN_LIT_STRING.str
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_str = _symbols[offset + 1];
					final String str = (String) _symbol_str.value;
					 return new NodeLiteral(new TypeString(), str);
				}
			},
			new Action() {	// [114] literal = TOKEN_TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), true);
				}
			},
			new Action() {	// [115] literal = TOKEN_FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), false);
				}
			},
			new Action() {	// [116] literal = TOKEN_NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(null, null);
				}
			}
		};

 
	report = new Events();
	stackEnvironment.PushEnvironment("Global"); 
	procedureEnvironment.pushEnvironment("Global");
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
