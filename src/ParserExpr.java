import abstractTree.*;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserExpr.grammar".
 */
public class ParserExpr extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pLaajBmq0KXK$IshIrQiTQ7$LjrMxSkdNhreK8hWKL11U2WXkjfLHGKH3N$aHVzVswdfb" +
		"S9KJz0PtmtNFlkPD9PX80b#X05oRGYsuCOmIZ67FEK6iv8WYGn3ZZ57ovmZIp3DhHfZ60qI" +
		"o58gl4ZszrGAiq1iDCtfrQiiYX4taKq8C#zACadoXZKZuOFVXSAUbM3NXtfYKTq3CyIu$ON" +
		"IQOPRdpd4QF#mypmypZwN$xLlEHNfY5VOlHorUC#t9X12fLkB5EDeM3kaBIP8SOKYCbdLTM" +
		"dI5rCajMrJidSsH3wmioJxR80jcr$bzmd91Ziapso1avrTwIwgBgckgswhvgLVL0jHPxHZr" +
		"MDrGF$tklsFoZM5r1PCWRUIKlv9ayEVTHkm#HcVVIb3kvbHkvPjMCB6BSboyux9#Ge1F7Lq" +
		"sI5F5#KVm2GV1VHW==");
 

static public class MyEvents extends beaver.Parser.Events {
	
	public void syntaxError(Symbol token) {
		System.err.print("Erreur de syntaxe ligne ");
		System.err.println(Symbol.getLine(token.getStart()));
		System.err.print("Token inattendu: ");
		System.err.println(Terminals.NAMES[token.getId()]);
	}
};

	private final Action[] actions;

	public ParserExpr() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] Program = Declarations.decs SEMICOLON Expression.exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_decs = _symbols[offset + 1];
					final TreeMap decs = (TreeMap) _symbol_decs.value;
					final Symbol _symbol_exp = _symbols[offset + 3];
					final AbstTree exp = (AbstTree) _symbol_exp.value;
					 TreeMap tree = new TreeMap(decs); tree.addTree(exp); return tree;
				}
			},
			new Action() {	// [1] Declarations = Declarations.decs SEMICOLON Declaration.dec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_decs = _symbols[offset + 1];
					final TreeMap decs = (TreeMap) _symbol_decs.value;
					final Symbol _symbol_dec = _symbols[offset + 3];
					final AbstTree dec = (AbstTree) _symbol_dec.value;
					 TreeMap tree = new TreeMap(decs); tree.addTree(dec); return tree;
				}
			},
			new Action() {	// [2] Declarations = Declaration.dec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_dec = _symbols[offset + 1];
					final AbstTree dec = (AbstTree) _symbol_dec.value;
					 TreeMap tree = new TreeMap(dec); return tree;
				}
			},
			new Action() {	// [3] Declaration = ID.id ASSIGN Expression.exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_exp = _symbols[offset + 3];
					final AbstTree exp = (AbstTree) _symbol_exp.value;
					 TreeIdentifier tree = new TreeIdentifier(id, exp); return tree;
				}
			},
			new Action() {	// [4] Expression = Expression.l PLUS Expression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final AbstTree l = (AbstTree) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final AbstTree r = (AbstTree) _symbol_r.value;
					 TreeOperator tree = new TreeOperator(Keywords.PLUS, l, r); return tree;
				}
			},
			new Action() {	// [5] Expression = Expression.l MINUS Expression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final AbstTree l = (AbstTree) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final AbstTree r = (AbstTree) _symbol_r.value;
					 TreeOperator tree = new TreeOperator(Keywords.MINUS, l, r); return tree;
				}
			},
			new Action() {	// [6] Expression = Expression.l MULT Expression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final AbstTree l = (AbstTree) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final AbstTree r = (AbstTree) _symbol_r.value;
					 TreeOperator tree = new TreeOperator(Keywords.MULTIPLY, l, r); return tree;
				}
			},
			new Action() {	// [7] Expression = Expression.l DIV Expression.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final AbstTree l = (AbstTree) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final AbstTree r = (AbstTree) _symbol_r.value;
					 TreeOperator tree = new TreeOperator(Keywords.DIVIDE, l, r); return tree;
				}
			},
			new Action() {	// [8] Expression = MINUS Expression.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 2];
					final AbstTree l = (AbstTree) _symbol_l.value;
					 TreeOperator tree = new TreeOperator(Keywords.MINUS, l); return tree;
				}
			},
			new Action() {	// [9] Expression = LPAR Expression RPAR.tree
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol tree = _symbols[offset + 3];
					 return tree;
				}
			},
			new Action() {	// [10] Expression = UFCT.op LPAR Expression.un RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_op = _symbols[offset + 1];
					final String op = (String) _symbol_op.value;
					final Symbol _symbol_un = _symbols[offset + 3];
					final AbstTree un = (AbstTree) _symbol_un.value;
					 TreeOperator tree = new TreeOperator(Keywords.valueOf(op), un); return tree;
				}
			},
			new Action() {	// [11] Expression = BFCT.op LPAR Expression.l COLON Expression.r RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_op = _symbols[offset + 1];
					final String op = (String) _symbol_op.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final AbstTree l = (AbstTree) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final AbstTree r = (AbstTree) _symbol_r.value;
					 TreeOperator tree = new TreeOperator(Keywords.valueOf(op), l, r); return tree;
				}
			},
			new Action() {	// [12] Expression = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 TreeIdentifier tree = new TreeIdentifier(id); return tree;
				}
			},
			new Action() {	// [13] Expression = INTEGER.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final Integer i = (Integer) _symbol_i.value;
					 TreeInteger tree = new TreeInteger(i); return tree;
				}
			},
			new Action() {	// [14] Expression = FLOAT.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Double f = (Double) _symbol_f.value;
					 TreeFloat tree = new TreeFloat(f); return tree;
				}
			},
			new Action() {	// [15] Expression = PI.pi
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_pi = _symbols[offset + 1];
					final Double pi = (Double) _symbol_pi.value;
					 TreeFloat tree = new TreeFloat(pi); return tree;
				}
			},
			new Action() {	// [16] Expression = NEP.nep
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_nep = _symbols[offset + 1];
					final Double nep = (Double) _symbol_nep.value;
					 TreeFloat tree = new TreeFloat(nep); return tree;
				}
			}
		};


	report = new MyEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
