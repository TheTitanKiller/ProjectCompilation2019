//////////////////////////////////////////////////
// version 20190403
// Difference avec version 20190401
// - Case respecte plus la syntaxe Lea
// - Quelques typos
//////////////////////////////////////////////////

%package "main";
%class "Parser";
%import "node.*";
%import "type.*";
%import "environment.*";
%import "java.util.ArrayList";
%import "java.util.Iterator";

%embed {: 
	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}
	
	public void semanticError(String msg, Symbol token) {
		System.err.format("*** " + msg + " ligne %d, colonne %d\n",
			Symbol.getLine(token.getStart()),
			Symbol.getColumn(token.getStart()));
	}
	
	/*
	 * Environnements disponibles pour la gestion des types complexes, des variables et des fonctions.
	 */
	private Environment typeEnvironment = new Environment("types");
	private Environment procedureEnvironment = new Environment("procedures");
	private StackEnvironment stackEnvironment = new StackEnvironment("local_variables_stack");
	private String type_declaration_name;
	
	public void backtrace() 
	{
		typeEnvironment.backtrace();
		procedureEnvironment.backtrace();
		stackEnvironment.backtrace();
	}
	
:};

%init {: 
	report = new Events();
	stackEnvironment.pushEnvironment("Global"); 
:};

// KEYWORDS
%terminals TOKEN_TYPE, TOKEN_STRING, TOKEN_INTEGER, TOKEN_BOOLEAN, TOKEN_ARRAY, TOKEN_OF, TOKEN_STRUCT;
%terminals TOKEN_VAR, TOKEN_PROCEDURE, TOKEN_FUNCTION, TOKEN_BEGIN, TOKEN_END, TOKEN_NEW, TOKEN_DISPOSE;
%terminals TOKEN_PRINTLN, TOKEN_READLN, TOKEN_RETURN, TOKEN_IF, TOKEN_THEN, TOKEN_ELSE, TOKEN_WHILE, TOKEN_DO;
%terminals TOKEN_SWITCH, TOKEN_CASE, TOKEN_DEFAULT;

// PONCTS
%terminals TOKEN_SEMIC, TOKEN_DOTDOT, TOKEN_COLON, TOKEN_COMMA;
%terminals TOKEN_LPAR, TOKEN_RPAR, TOKEN_LBRACKET, TOKEN_RBRACKET, TOKEN_LBRACE, TOKEN_RBRACE;

// OPERATORS
%terminals TOKEN_AFF, TOKEN_CIRC;
%terminals TOKEN_PLUS, TOKEN_MINUS, TOKEN_TIMES, TOKEN_DIV;
%terminals TOKEN_AND, TOKEN_OR, TOKEN_NOT;
%terminals TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;

// LITERALS
%terminals TOKEN_IDENTIFIER, TOKEN_LIT_INTEGER, TOKEN_LIT_STRING, TOKEN_TRUE, TOKEN_FALSE, TOKEN_NULL; 

/***
* A completer
***/

//PRIORITIES
%left TOKEN_TIMES, TOKEN_DIV;
%left TOKEN_PLUS; 
%right TOKEN_MINUS;

%left TOKEN_AND, TOKEN_OR;
%right TOKEN_NOT;
%left TOKEN_LT, TOKEN_LE, TOKEN_GT, TOKEN_GE, TOKEN_EQ, TOKEN_NE;

%right TOKEN_IF, TOKEN_THEN, TOKEN_ELSE;

//TYPES

//TODO to change each if needed
%typeof program	                   ="NodeList";
%typeof type_declaration_part      ="NodeList";
%typeof type_declaration_list      ="Node";
%typeof type_declaration           ="Node";
%typeof type_declaration_head      ="String";
%typeof type                       ="Type";
%typeof simple_type                ="Type";
%typeof named_type                 ="Type";
%typeof index_type                 ="Type";
%typeof enumerated_type            ="Type";
%typeof init_enumerated_type       ="Type";
%typeof subrange_type              ="Type";
%typeof array_type                 ="TypeArray";
%typeof range_type                 ="TypeRange";
%typeof pointer_type               ="Type";
%typeof structure_type             ="Type";
%typeof feature_list_type          ="Type";
%typeof feature_type               ="Type";
%typeof variable_declaration_part  ="NodeList";
%typeof variable_declaration_list  ="Node";
%typeof variable_declaration       ="Node";
%typeof identifier_list            ="IdentifierList";
%typeof procedure_definition_part  ="NodeList";
%typeof procedure_definition_list  ="Node";
%typeof procedure_definition       ="Node";
%typeof procedure_definition_head  ="NodeId";
%typeof procedure_declaration_head ="NodeId";
%typeof procedure_head             ="NodeId";
%typeof argt_part                  ="TypeTuple";
%typeof argt_list                  ="NodeList";
%typeof argt                       ="Node";
%typeof block                      ="Node";
%typeof statement_list             ="Node";
%typeof statement                  ="Node";
%typeof simple_statement           ="Node";
%typeof assignment_statement       ="NodeAssign";
%typeof procedure_statement        ="Node";
%typeof procedure_expression       ="Node";
%typeof expression_part            ="NodeList";
%typeof expression_list            ="Node";
%typeof new_statement              ="Node";
%typeof dispose_statement          ="Node";
%typeof println_statement          ="Node";
%typeof readln_statement           ="Node";
%typeof return_statement           ="NodeReturn";
%typeof structured_statement       ="Node";
%typeof if_statement               ="Node";
%typeof while_statement            ="Node";
%typeof case_statement_list        ="NodeList";
%typeof case_statement             ="NodeList";
%typeof case_default 	           ="NodeCase";
%typeof variable_access            ="NodeExp";
%typeof expression                 ="NodeExp";
%typeof literal                    ="NodeLiteral";

%typeof TOKEN_LIT_INTEGER 		   = "Integer";
%typeof TOKEN_LIT_STRING  		   = "String";
%typeof TOKEN_IDENTIFIER 		   = "String";

%typeof procedure_name 		   	   = "NodeId";

%goal program;


/*Regles pour code*/


program=
	type_declaration_part.tydec
	variable_declaration_part.vardec
	procedure_definition_part.procdec
	empty_main
	TOKEN_BEGIN
	statement_list.stmn
	TOKEN_END
	{: stackEnvironment.popEnvironment(); return new NodeList(tydec,vardec,procdec,stmn); :}
	;

empty_main = 
	{: stackEnvironment.pushEnvironment("Main"); return new TypeVoid(); :}
	;

type_declaration_part= 
	/* empty */	
	| TOKEN_TYPE type_declaration_list
	;
	
type_declaration_list=
	type_declaration_list type_declaration
	| type_declaration
	;
	
type_declaration=
	type_declaration_head.tname TOKEN_AFF type.ty TOKEN_SEMIC 	{: 	NodeId node = new NodeId(tname, ty); stackEnvironment.putVariable(tname, node); 
																	return node; :}
	;
	
type_declaration_head=
	TOKEN_IDENTIFIER
	;
	
type=
	simple_type
	| named_type		
	| index_type
	| array_type
	| pointer_type
	| structure_type
	;
	
simple_type=
	TOKEN_STRING		{: return new TypeString(); :}
	| TOKEN_INTEGER		{: return new TypeInt(); :}
	| TOKEN_BOOLEAN		{: return new TypeBoolean(); :}
	;
	
named_type=
	TOKEN_IDENTIFIER.name {: return typeEnvironment.getVariable(name); :}/*TODO env*/
	;
	
index_type=
	enumerated_type
	| subrange_type
	;
	
enumerated_type=
	init_enumerated_type TOKEN_LPAR identifier_list TOKEN_RPAR 
	;
	
init_enumerated_type=
	;

subrange_type= 
	TOKEN_LIT_INTEGER.int1 TOKEN_DOTDOT TOKEN_LIT_INTEGER.int2 		{: return new TypeArrayRange(new TypeInt(int1), new TypeInt(int2)); :}
	| TOKEN_IDENTIFIER.name1 TOKEN_DOTDOT TOKEN_IDENTIFIER.name2	/*{: int1 = typeEnvironment.getVariable(name1); 
																		int2 = typeEnvironment.getVariable(name2); 
																		return new TypeEnumRange(int1, int2); :}*/
	;
	
array_type=
	TOKEN_ARRAY TOKEN_LBRACKET range_type.r TOKEN_RBRACKET TOKEN_OF type.ty {: return new TypeArray(r, ty); :}
	;
	
range_type=
	enumerated_type 	
	| subrange_type
	| named_type	
	;
	
pointer_type=
	TOKEN_CIRC type.ty 	{: return new TypePointer(ty); :}
	;
	
structure_type=
	TOKEN_STRUCT TOKEN_LBRACE feature_list_type TOKEN_RBRACE /*TODO env*/
	;
	
feature_list_type=
	feature_list_type feature_type
	| feature_type
	;
	
feature_type=
	TOKEN_IDENTIFIER TOKEN_COLON type TOKEN_SEMIC /*TODO env*/
	;
	
variable_declaration_part= 
	/* empty */ 
	| TOKEN_VAR variable_declaration_list. list 			{: return list; :}
	;
	
variable_declaration_list=
	variable_declaration_list.list variable_declaration.dec {: list.add(dec); return list; :}
	| variable_declaration
	;
	
variable_declaration=
	identifier_list.list TOKEN_COLON type.ty TOKEN_SEMIC 
	{: 	
		NodeList node_list = new NodeList(); 
		Iterator<String> itr = list.iterator();
		while(itr.hasNext()) 
		{
	         String name = itr.next();
	         NodeId node = new NodeId(name, ty);
	         stackEnvironment.putVariable(name, node);
	         node_list.add(node);
      	} 
      	return node_list;
    :}
	;
	
identifier_list=
	identifier_list.list TOKEN_COMMA TOKEN_IDENTIFIER.name 	{: list.add(name); return list; :}
	| TOKEN_IDENTIFIER.name 								{: return new IdentifierList(name); :}
	;
	
procedure_definition_part=
	| procedure_definition_list
	;
	
procedure_definition_list=
	procedure_definition_list.list procedure_definition.node		{: list.add(node); return list; :}
	| procedure_definition.node                        				{: return new NodeList(node); :}
	;
	
procedure_definition=
	procedure_definition_head.h block.b				{: stackEnvironment.popEnvironment(); return new NodeList(h,b); :}
	| procedure_declaration_head.h TOKEN_SEMIC		{: stackEnvironment.popEnvironment(); return h; :}
	;

procedure_definition_head=
	procedure_head.node {: try 
								{
									procedureEnvironment.putVariable(node.getName(), node);
								}
							 	catch (Error err)
							 	{
							 		procedureEnvironment.replaceVariable(node.getName(), node);
							 	}
							 	return node; :}
	;
	
procedure_declaration_head=
	procedure_head.node 	{: procedureEnvironment.putVariable(node.getName(),  node); return node; :}
	;
	
procedure_head=
	TOKEN_PROCEDURE procedure_name.nid TOKEN_LPAR argt_part.args TOKEN_RPAR 
						{: 	NodeId node = new NodeId(nid.getName(), new TypeFunct(nid.getName(), args, new TypeVoid())); 
							return node; 
						:}
						
	| TOKEN_FUNCTION procedure_name.nid TOKEN_LPAR argt_part.args TOKEN_RPAR TOKEN_COLON type.ty
						{: 	NodeId node = new NodeId(nid.getName(), new TypeFunct(nid.getName(), args, ty)); 
							return node; 
						:}
	;

procedure_name = 
	TOKEN_IDENTIFIER.namefct 					{: stackEnvironment.pushEnvironment(namefct); return new NodeId(namefct, null); :}
	;

argt_part=
	/* empty */
	| argt_list.list
												{:
													TypeTuple type_params = new TypeTuple();
													Iterator<Node> itr = list.iterator();
													while(itr.hasNext()) 
													{
														 NodeExp n =(NodeExp)(itr.next());
												         Type type = n.getType();
												         type_params.add(type);
											      	} 
											      	return type_params;
											    :}
	;
	
argt_list=
	argt_list.list TOKEN_COMMA argt.node   		{: list.add(node); return list; :}
	| argt.node            						{: return new NodeList(node); :}
	;
	
argt=
	TOKEN_IDENTIFIER.name TOKEN_COLON type.ty	{: 	NodeId node = new NodeId(name, new TypeFeature (name, ty)); stackEnvironment.putVariable(name, node); 
													return node; :}
	;
	
block=
	variable_declaration_part.dec
	TOKEN_BEGIN
	statement_list.stmn
	TOKEN_END 			
											{: return new NodeList(dec, stmn); :}	
	;

statement_list=
	statement_list.list statement.node		{: list.add(node); return list; :}
	| statement.node                      	{: return new NodeList(node); :}
	;
	
statement=
	simple_statement
	| structured_statement
	;
	
simple_statement=
	assignment_statement
	| procedure_statement
	| new_statement
	| dispose_statement
	| println_statement
	| readln_statement
	| return_statement.r 											{: return new NodeReturn(r); :}
	;
	
assignment_statement=
	variable_access.v TOKEN_AFF expression.e TOKEN_SEMIC 			{: return new NodeAssign(v, e); :}
	;
	
procedure_statement=
	procedure_expression TOKEN_SEMIC
	;
	
procedure_expression=
	TOKEN_IDENTIFIER.name TOKEN_LPAR expression_part.ep TOKEN_RPAR		{: 	NodeId funct = procedureEnvironment.getVariable(name); 
																			return new NodeCallFct( name, (TypeFunct)funct.getType(), ep); :}
	;
	
expression_part=
	/* empty */
	| expression_list
	;
	
expression_list=
	expression_list.list TOKEN_COMMA expression.node   	{: list.add(node); return list; :}
	| expression.node                   				{: return new NodeList(node); :}
	;	
	
new_statement=
	TOKEN_NEW variable_access.v TOKEN_SEMIC 			{: return new NodeNew(v); :}
	;
	
dispose_statement=
	TOKEN_DISPOSE variable_access.v TOKEN_SEMIC 		{: return new NodeDispose(v); :}
	;
	
println_statement=
	TOKEN_PRINTLN expression TOKEN_SEMIC
	;	
	
readln_statement=
	TOKEN_READLN expression TOKEN_SEMIC
	;
	
return_statement=
	TOKEN_RETURN expression.e TOKEN_SEMIC 				{: return new NodeReturn(e); :}
	;
	
structured_statement=
	block
	| if_statement
	| while_statement
	| switch_statement
	;
	
if_statement=
	TOKEN_IF expression.e TOKEN_THEN statement.stm1 TOKEN_ELSE statement.stm2 	{: return new NodeIf(e, stm1, stm2); :}
	| TOKEN_IF expression.e TOKEN_THEN statement.stm 							{: return new NodeIf(e, stm); :}
	;
	
while_statement=
	TOKEN_WHILE expression.e TOKEN_DO statement.stm 							{: return new NodeWhile(e, stm); :}
	;
	
switch_statement=
	TOKEN_SWITCH expression.e TOKEN_BEGIN case_statement_list.stm TOKEN_END 	{: return new NodeSwitch(e, stm); :}
	;
	
case_statement_list=
	case_statement_list.list case_statement.cstmn case_default.cdef				{: list.add(cstmn); list.add(cdef); return list; :}
	| case_statement						
	;
	
case_statement=
	TOKEN_CASE identifier_list.list TOKEN_COLON statement.stm			{: 	
																			NodeList node_list = new NodeList(); 
																			Iterator<String> itr = list.iterator();
																			while(itr.hasNext()) 
																			{
																		         String name = itr.next();
																		         NodeCase newcase = new NodeCase(name, stm);
																		         node_list.add(newcase);
																	      	} 
																	      	return node_list;
																	    :}
	;

case_default=
	/* empty */
	| TOKEN_DEFAULT TOKEN_COLON statement.stm 							{: return new NodeCase(stm); :}
	;
		
variable_access=
	TOKEN_IDENTIFIER.name 												{: return stackEnvironment.getVariable(name); :}
	| variable_access.t TOKEN_LBRACKET expression.i TOKEN_RBRACKET 		{: return new NodeArrayAccess(t, i); :}
	| expression.e TOKEN_CIRC 											{: return new NodePtrAccess(e); :}
	;
	
expression=
	expression.e1 TOKEN_PLUS expression.e2 		{: return new NodeOp("+", e1, e2); :}
	| expression.e1 TOKEN_MINUS expression.e2 	{: return new NodeOp("-", e1, e2); :}
	| expression.e1 TOKEN_TIMES expression.e2 	{: return new NodeOp("*", e1, e2); :}
	| expression.e1 TOKEN_DIV expression.e2 	{: return new NodeOp("/", e1, e2); :}
	| TOKEN_MINUS expression.e 					{: return new NodeOp("-", e); :}
	
	| expression.e1 TOKEN_OR expression.e2 		{: return new NodeOp("||", e1, e2); :}
	| expression.e1 TOKEN_AND expression.e2 	{: return new NodeOp("&&", e1, e2); :}

	| expression.e1 TOKEN_LT expression.e2 		{: return new NodeOp("<", e1, e2); :}
	| expression.e1 TOKEN_LE expression.e2 		{: return new NodeOp("<=", e1, e2); :}
	| expression.e1 TOKEN_GT expression.e2 		{: return new NodeOp(">", e1, e2); :}
	| expression.e1 TOKEN_GE expression.e2 		{: return new NodeOp(">=", e1, e2); :}
	| expression.e1 TOKEN_EQ expression.e2 		{: return new NodeOp("==", e1, e2); :}
	| expression.e1 TOKEN_NE expression.e2		{: return new NodeOp("!=", e1, e2); :}
	
	| TOKEN_NOT expression.e 					{: return new NodeOp("!", e); :}
		
	| TOKEN_LPAR expression.e TOKEN_RPAR		{: return e; :}
	| procedure_expression.p 					{: return p; :}
	| variable_access.v							{: return v; :}		
	| literal.l 								{: return l; :}
	;
	
literal=
	TOKEN_LIT_INTEGER.val 						{: return new NodeLiteral(new TypeInt(), val); :}
	| TOKEN_LIT_STRING.str 						{: return new NodeLiteral(new TypeString(), str); :}
	| TOKEN_TRUE 								{: return new NodeLiteral(new TypeBoolean(), true); :}
	| TOKEN_FALSE 								{: return new NodeLiteral(new TypeBoolean(), false); :}
	| TOKEN_NULL 								{: return new NodeLiteral(null, null); :}
	;
	